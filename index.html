<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Reconnaissance MNIST ONNX.js</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      text-align: center;
    }
    canvas {
      border: 2px solid #000;
      background-color: black;
      touch-action: none; /* Pour éviter scroll sur mobile */
      margin-bottom: 10px;
    }
    button {
      padding: 10px 20px;
      font-size: 1.2em;
      cursor: pointer;
    }
    #result {
      margin-top: 20px;
      font-size: 1.5em;
      font-weight: bold;
      min-height: 1.5em;
    }
  </style>
</head>
<body>
  <h1>Reconnaissance de chiffres manuscrits MNIST</h1>
  <canvas id="canvas" width="280" height="280"></canvas><br />
  <button id="clearBtn">Effacer</button>
  <button id="predictBtn">Prédire</button>
  <div id="result"></div>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    // Initialisation canvas et contexte
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.lineCap = 'round';
    ctx.lineWidth = 20;
    ctx.strokeStyle = 'white';
    ctx.fillStyle = 'black';

    // Remplit fond en noir au départ
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let drawing = false;

    // Gestion dessin souris / tactile
    function startPosition(e) {
      drawing = true;
      draw(e);
    }
    function finishedPosition() {
      drawing = false;
      ctx.beginPath();
    }
    function draw(e) {
      if (!drawing) return;
      e.preventDefault();
      let rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y);
    }

    canvas.addEventListener('mousedown', startPosition);
    canvas.addEventListener('mouseup', finishedPosition);
    canvas.addEventListener('mousemove', draw);

    canvas.addEventListener('touchstart', startPosition);
    canvas.addEventListener('touchend', finishedPosition);
    canvas.addEventListener('touchmove', draw);

    // Effacer le canvas
    document.getElementById('clearBtn').addEventListener('click', () => {
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      document.getElementById('result').textContent = '';
    });

    // Prétraitement : convertir le canvas 280x280 en image 28x28 normalisée Float32Array
    function preprocess() {
      // Créer un canvas offscreen 28x28
      const offCanvas = document.createElement('canvas');
      offCanvas.width = 28;
      offCanvas.height = 28;
      const offCtx = offCanvas.getContext('2d');

      // Dessiner le canvas original réduit dans le canvas 28x28 (mise à l’échelle)
      offCtx.drawImage(canvas, 0, 0, 28, 28);

      // Récupérer les pixels RGBA
      const imgData = offCtx.getImageData(0, 0, 28, 28);
      const data = imgData.data;

      // Construire un tableau Float32Array avec la luminosité inversée (fond noir = 0, trait blanc = 1)
      // Le modèle MNIST attend un input entre 0 et 1, 1 = trait fort
      const input = new Float32Array(28 * 28);
      for (let i = 0; i < 28 * 28; i++) {
        // Pixel gris (r,g,b sont égaux car dessin en blanc sur noir)
        // data est RGBA (4 octets par pixel)
        const r = data[i * 4];
        // Normaliser entre 0 et 1, inverser: fond noir (r~0) => 0, trait blanc (r~255) => 1
        input[i] = r / 255;
      }
      return input;
    }

    // Chargement modèle ONNX (assurez-vous de bien avoir le fichier mnist.onnx au bon endroit)
    let session;
    async function loadModel() {
      session = await ort.InferenceSession.create('mnist_model.onnx');
      console.log('Modèle chargé');
    }

    // Prédiction
    async function predict() {
      if (!session) {
        alert('Le modèle n\'est pas chargé.');
        return;
      }
      const inputTensor = preprocess();
      // Création du tenseur avec la bonne forme [1, 1, 28, 28] (batch=1, channel=1, height=28, width=28)
      const tensor = new ort.Tensor('float32', inputTensor, [1, 1, 28, 28]);

      // Faire l'inférence
      const feeds = {};
      feeds[session.inputNames[0]] = tensor;

      try {
        const results = await session.run(feeds);
        const output = results[session.outputNames[0]]; // Tensor output
        // Trouver l'indice de la classe avec la probabilité max
        const data = output.data;
        let maxProb = data[0];
        let maxIndex = 0;
        for (let i = 1; i < data.length; i++) {
          if (data[i] > maxProb) {
            maxProb = data[i];
            maxIndex = i;
          }
        }
        document.getElementById('result').innerHTML = `Chiffre prédit : ${maxIndex}<br>Logits : [${Array.from(data).map(x => x.toFixed(2)).join(', ')}]`;
      } catch (e) {
        console.error(e);
        alert('Erreur lors de la prédiction.');
      }
    }

    // Charger modèle dès que la page est prête
    window.onload = loadModel;

    // Bouton prédiction
    document.getElementById('predictBtn').addEventListener('click', predict);
  </script>
</body>
</html>
